<!DOCTYPE html>
<html lang="zh-CN" data-bs-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      href="https://i.328888.xyz/2023/04/14/ixDL13.jpeg"
      type="image/png" />
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
    <link
      href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.3.0-alpha3/css/bootstrap.css"
      rel="stylesheet" />
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.3.0-alpha3/js/bootstrap.bundle.js"></script>
    <title>花花</title>
  </head>
  <body>
    <ol>
      JavaScript中，set对象是一种集合，它可以存储任何类型的唯一值，无论是原始值还是对象引用
      <li>set对象中的值只能出现一次，不会重复。</li>
      <li>set对象中的值是按照插入顺序排列的，可以通过迭代器访问。</li>
      <li>
        set对象中的值的相等性是基于SameValueZero算法，这意味着+0与-0不重复；undefined与undefined不重复；NaN与NaN
        重复
      </li>
      <li>set对象有多种方法，可以添加、删除、清空、检查、遍历集合中的元素</li>
      <li>set对象也可以实现基本的集合操作，如并集、交集、差集等</li>
    </ol>
    <ol>
      <li>add(value)：在set对象尾部添加一个元素。返回该set对象</li>
      <li>clear()：移除set对象内的所有元素</li>
      <li>
        delete(value)：移除值为value的元素，并返回一个布尔值来表示是否移除成功
      </li>
      <li>has(value)：返回一个布尔值，表示该值在set中存在与否。</li>
      <li>
        entries()：返回一个新的迭代器对象，该对象包含set对象中的按插入顺序排列的所有元素的值的[value,value]数组。(为了使这个方法和Map对象保持相似，每个值的键和值相等)
      </li>
      <li>
        forEach(callbackFn[,thisArg])：按照插入顺序，为set对象中的每一个值调用一次callbackFn。如果提供了thisArg参数，回调中的this会是这个参数
      </li>
      <li>
        values()：返回一个新的迭代器对象，该对象包含set对象中的按插入顺序排列的所有元素的值。
      </li>
      <li>
        keys()：与values()方法相同，返回一个新的迭代器对象，该对象包含set对象中的按插入顺序排列的所有元素的值。
      </li>
      <li>
        Set.prototype[@@iterator]()：返回一个新的迭代器对象，该对象包含set对象中的按插入顺序排列的所有元素的值
      </li>
    </ol>
    <script>
      // 创建一个空的Map对象
      let mySet = new Set();
      // 使用set()方法添加一些键值对
      mySet.add("a");
      mySet.add(1);
      mySet.add(["arr1", "arr2"]);
      mySet.add({ objkey: "objvalue" });
      console.log(mySet);
      // 使用has()方法检查是否有指定键的值
      console.log(mySet.has("a")); // true
      console.log(mySet.has(1)); // true
      console.log(mySet.has(["arr1", "arr2"])); // true
      console.log(mySet.has({ objkey: "objvalue" })); // true
      console.log(mySet.has(123)); // false
      // 使用delete()方法删除指定键的值
      console.log(mySet.delete("a")); // true
      console.log(mySet.delete(123)); // false
      // 使用clear()方法删除所有的键值对
      /* mySet.clear();
      console.log(mySet.size); // 0 */
      // 使用keys()方法获取所有的值
      let keys = mySet.keys();
      for (let key of keys) {
        console.log(key); //=>1  =>['arr1', 'arr2']  =>{ objkey: 'objvalue' }
      }
      // 使用values()方法获取所有的值
      let values = mySet.values();
      for (let value of values) {
        console.log(value); //=>1  =>['arr1', 'arr2']  =>{ objkey: 'objvalue' }
      }
      // 使用entries()方法获取所有的键值对
      let entries = mySet.entries();
      for (let entry of entries) {
        console.log(entry); //=>[1,1]   =>[['arr1', 'arr2'], ['arr1', 'arr2']]   =>[{ objkey: 'objvalue' },{ objkey: 'objvalue' }]
      }
      // 使用forEach()方法对每个键值对执行一个函数
      mySet.forEach((value, key) => {
        console.log(key + ": " + value); //=>1: 1  =>arr1,arr2: arr1,arr2   =>[object Object]: [object Object]
      });
    </script>
    <script>
      // 数组去重
      var mySet2 = new Set([1, 2, 3, 4, 4]);
      [...mySet2]; // [1, 2, 3, 4]
      // 并集
      var a = new Set([1, 2, 3]);
      var b = new Set([4, 3, 2]);
      var union = new Set([...a, ...b]); // {1, 2, 3, 4}
      // 交集
      var a = new Set([1, 2, 3]);
      var b = new Set([4, 3, 2]);
      var intersect = new Set([...a].filter((x) => b.has(x))); // {2, 3}
      // 差集
      var a = new Set([1, 2, 3]);
      var b = new Set([4, 3, 2]);
      var difference = new Set([...a].filter((x) => !b.has(x))); // {1}
    </script>
  </body>
</html>
